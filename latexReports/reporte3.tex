%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  para un artÃ­culo en LaTeX en espaÃ±ol.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[]{article}
% Esto es para poder escribir acentos directamente:
\usepackage[latin1]{inputenc}
% Esto es para que el LaTeX sepa que el texto estÃ¡ en espaÃ±ol:
\usepackage[spanish]{babel}
%para cambiar los margenes del texto
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
% Paquetes de la AMS:
%\usepackage{amsmath, amsthm, amsfonts,float}
\graphicspath{ {../Tarea_3/images/} }


%--------------------------------------------------------------------------
\title{Reporte práctica tres: Teoría de colas}
\author{José Anastacio Hernéndez Saldaña\\
  \small Posgrado de Ingeniería de Sistemas\\
  \small 1186622\\ 
  \small jose.hernandezsld@uanl.edu.mx
}

\begin{document}

\maketitle

\abstract{Este es un reporte sobre la práctica tres sobre el tema teoría de colas que se realizó en la clase de Simulación de Sistemas, cómputo paralelo en R.}


\section{Tarea: Diferencia en tiempos de ejecución de los diferentes ordenamientos al variar el numero de núcleos que realizan una tarea.}

La teoría de colas es el estudio de matemático de las líneas de espera dentro de un sistema. En esta práctica se estudió la fila de espera generada por las actividades que se mandaron a ejecutar y fueron atendidas por el procesador. Al utilizar el paralelismo, se aprovecha la característica incorporada a los procesadores desde hace algunos años de contar con más de un núcleo de procesamiento, asi que la fila de espera se divide entre la cantidad de servidores (núcleos del procesador) asignados y el conjunto de actividades tendría que completarse en un tiempo menor que el tiempo realizado si se utilizara solo un núcleo del procesador.

\subsection{Diseño del Experimento}

Para este experimento se utilizó una función para identificar si dado un número $n$, este es primo o no, esto lo realiza revisando el modulo generado al dividir el número $n$ entre el número dos, y los número impares desde tres hasta $\sqrt{n}$, si el modulo es cero con algún valor, entonces el número no es primo y si para ningún valor del rango el modulo es 0, entonces el número $n$ es primo. Este algoritmo en el peor de los casos, hace aproximadamente $\sqrt{\frac{n}{2}}$ operaciones para saber si un número es primo.

Ahora que ya se tiene la función que sera efectuada por el procesador, se generó una cola de trabajo con una cantidad de números a los cuales había que identificar si son primos o no.

Tomando como base el ejercicio en la \href{http://elisa.dyndns-web.com/teaching/comp/par/p3.html}{página del curso}, donde 3 series de números secuenciales fueron utilizados: ordenados de manera ascendente, ordenados de manera descendente y ordenados de manera aleatoria. Se comenzó con este ejemplo para comenzar la practica, y las series de números utilizados eran los números del 50,000 al 100,000.

Para comenzar la experimentación, se utilizó una computadora con las siguientes especificaciones, Procesador Intel Core i7-4790 CPU @ 3.6Ghz $\times$ 8 y Memoria RAM de 24 Gb. Con lo que se contaban con 7 núcleos de procesador para realizar los experimentos. Se dejó 1 núcleo para procesos del Sistema operativo y que no fuera a afectar los resultados al utilizar los 8 núcleos del procesador.

Para el experimento se utilizaron 30 iteraciones para cada experimento y el código implementado para la paralelizacion fue el de la librería parallel de R, iterando desde 1 núcleo hasta 7, y también se usó un código que se implementaba sin llamar a la librería y se usara solo 1 núcleo, para comparar el tiempo entre el código que llamaba y no llamaba a la librería.


\begin{figure}
  \centering
  \includegraphics[width=0.6\textheight]{boxplotComplete50000_100000R30C7}
  \caption{Tiempos alcanzados por cada tarea y cada núcleos en los primeros experimentos}
  \label{fig::figura1} 
\end{figure}


\begin{figure}
  \centering
  \includegraphics[width=0.6\textheight]{boxplotbyNucleos50000_100000R30C7}
  \caption{Tiempos alcanzados por cada tarea dividido por núcleo}
  \label{fig::figura2} 
\end{figure}

\subsection{Resultados}
  
Los resultados obtenidos de esa experimentación son los mostrados en la figura  \ref{fig::figura1}. De donde se pudieron observar los siguiente puntos.
\begin{enumerate}
\item El tiempo requerido para terminar la tarea para un procesador que llamaba y que no llamaba a la librería fue mayor para el código que mandaba llamar a la librera parallel, esto debido al tiempo de procesamiento que toma el intentar paralelizar el código y que no es necesario porque solo hay 1 núcleo, mientras el código que no mandaba llamar a la librería comenzaba a laborar de inmediato, por lo que tenemos esa diferencia en los tiempos. Esta medición, sirvió también para tener como cota superior de lo que podríamos aceptar para utilizar la paralelizacion. Aquí cabe mencionar que se probo el código de la librería doPararllel para R, que también se utiliza para paralelizar tareas, pero por alguna razón esta implementación daba mayores tiempos que la opción iterativa de un núcleo, por lo que se descarto para ser utilizada en esta practica.
\item Para los implementaciones paralelas de más de dos núcleos, tenemos que sí hay una mejora en el tiempo de procesamiento de las tareas.
\item Se alcanzo el menor tiempo de procesamiento con cuatro núcleos utilizados, después de esto, los tiempos eran mayores que el tiempo obtenido por cuatro núcleos.
 \item Con respecto al tiempo entre los tipos de tareas, tenemos que no se ven diferencias significativas entre los tipos esto lo podemos observar en la figura \ref{fig::figura2}, es decir, independientemente de la tarea asignada, en la mayoría de los casos, terminaban al mismo tiempo, esto hace pensar que las tareas, es decir, las series de números, tenían la misma estructura y al dividirse entre núcleos cada núcleo tenia carga similar.
\end{enumerate}

\section{Extra Uno: Argumentar causas en los tiempos de ejecución debido a los núcleos asignados}

Como se pudo apreciar en el experimento anterior, hay una diferencia significativa al paralelizar con dos o más núcleos, esto debido a que al haber más núcleos disponibles las actividades se reparten entre los núcleos y se reduce el tiempo de procesamiento, sin embargo entre las tareas no hubo diferencias ¿por qué sucedió esto? pareciera que la estructura de la serie es las misma para las 3.

\subsection{Diseño del Experimento}

La primer hipótesis que se plantea es que la estructura de las 3 series es la misma, y que al dividirse las tarea se distribuye de la misma manera entre los núcleos. en las 3 seres, la mitad de los valores eran divisibles entre 2 y tardaba 1 comparación en saber que no eran primos, de la mitad restante, cerca de la tercera parte es divisible entre 3, tardando solo 2 comparaciones, etc. Esto hace que la tarea se realice en menos tiempo, pero también hace que las diferencias entre los núcleos sea homogéneas.

Lo que se planteo fue cambiar la serie para cambiar la estructura, en este caso se pensaron los siguientes casos.

\begin{enumerate}
\item Pares: Se utilizó un conjunto de $n$ números pares, esperando que sea el que menos tiempo toma ya que todos los elementos los procesara con una sola operación.
\item  Impares: Se utilizo un conjunto con $n$ números impares, esperando que demore mas que los casos secuenciales
\item Máximo Primo: se utilizó un conjunto donde se incluye el mayor número primo menor a el mayor numero utilizado $M$. este conjunto debería ser el que tome más tiempo de todos, ya que cada operación realiza tarda $\sqrt{\frac{M}{2}}$ operaciones.

  Los siguientes casos se utilizaron para indagar el funcionamiento de la paralelizacion, es decir, saber si se asignas las tareas en función del primer procesador que termine una tarea o si se divide la cola en partes iguales entre los procesadores y cada procesador trabaja con su propia linea de espera.
  
\item Medio ascendente: este conjunto consta de la mitad de los $n$ elementos como números pares, y la mitad otra son repeticiones de Máximo Primo.
\item Medio descendente: este conjunto es similar al anterior, solo que los primeros elementos son los Máximo Primo y la segunda mitad, números pares.  
\item Medio intercalado: este conjunto contiene de igual manera, mitad de números pares y mitad de números Máximo Primo, pero de manera intercalada.
\item Medio intercalado 2: este conjunto contiene de igual manera, mitad de números pares y mitad de números Máximo Primo, pero en 4 partes, primera cuarta parte de números Máximo Primo, la segunda cuarta parte de números pares, la tercera cuarta parte de Máximo Primo y la ultima parte de números pares.
\end{enumerate}

Para este experimento también se hicieron 30 replicas para cada núcleo, el intervalo usado fue el mismo de 50,000 a 100,000, solo que para las series de pares y impares, se necesitan 25,000 números pares y otros tantos impares, por lo que se tomaron del intervalo de 100,000 a 150,000, y el Máximo Primo utilizado fue el más cercano a 150,000, así que todos las series eran de 50,000 elementos.

\subsection{Resultados}

En estos resultados se mantuvo lo que se pudo apreciar en la primera experimentación, la paralelizacion de cuatro núcleos dio tiempos menores, y las series de números sucesivos ordenados ascendente, descendente y aleatorios se comportaron de manera similar al primer experimento.

Las estructura añadida de números pares, dio como se esperaba, una cota inferior, aunque hubo un resultado que fue interesante, como todos los números de la serie requieren de una cantidad constante de pasos para ser clasificados y esta cantidad de pasos es muy pequeña, se vieron mejores resultados con 1 solo núcleo que con paralelizacion de 5 o mas núcleos, seguramente debido al tiempo que se toma en paralelizar las tareas afecta al resultado final.

Las series de impares y de máximo primo, como también se esperaba dieron una  cota media y alta de lo que se podía esperar. Ademas, Máximo Primo que también contaba con un numero constante de operaciones pero mucho mayor a las demás, si se puede apreciar el efecto del paralelismo en esta tarea, donde  también, al ser asignados más de 4 núcleos, no se mostraba una mejora en el tiempo, estos resultados se pueden apreciar en la figura \ref{fig::figura3}.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textheight]{boxplotComplete3}
  \caption{Tiempos alcanzados para las tareas de pares, impares y máximo primo }
  \label{fig::figura3} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.6\textheight]{boxplotComplete2}
  \caption{Tiempos alcanzados para las tareas de mitades }
  \label{fig::figura4} 
\end{figure}


Los resultados más interesantes de este experimento fueron los que se encontraron para las series que sirvieron para ver el funcionamiento de la paralelizacion y la cola de espera que se genera para cada núcleo del procesador, estos resultados se aprecian en la figura \ref{fig::figura4}.

Aquí se puede apreciar que el tiempo que demora en realizar una tarea que toma la misma cantidad de operaciones, sí se ve afecta por el número de núcleos, los casos Medio ascendente y descendente, siempre tomaron tiempos similares para ser terminado en cada uno de los núcleos, pero los 2 casos intercalados mostraron siempre un tiempo de ejecución menor en comparación con los 2 anteriores, el caso mas evidente fue para 2 núcleos donde el tiempo que demoro en completar los medios ascendentes y descendente son muy similares a su tiempo de 1 solo núcleo, es decir, si la tarea se dividió en dos mitades, una mitad con los números primos y otra con los pares, el tiempo que demoraba era el tiempo que tarda en procesar $\frac{n}{32}$ Máximo primos y este tiempo es muy similar al de un núcleo ya que tiempo de procesar pares es muy pequeño, como se vio con el ejemplo de pares, por lo que seguramente la librería parallel parte el arreglo entre el número de núcleos asignados a la tarea. De no se asi, se esperaría que los 4 dieran resultados muy similares.

Para los cuatro casos, se vio también que se dio su mejor comportamiento con cuatro núcleos asignados, y para los casos siguientes no se vio mejora, al igual que en los experimentos anteriores.


\section{Extra Dos: Pruebas estadísticas a las series sucesivas}

Aquí se hizo una prueba de hipótesis para los resultados del experimento de la tarea, donde se establece que las varianzas de los resultados obtenidos por las series de números sucesivos ordenados de manera ascendente, descendente y aleatoria son iguales en cada núcleo para más de 2 núcleos.

Para poder realizar el análisis de varianza ANOVA, se necesita cumplir los supuestos de la independencia de las observaciones, tener distribución de residuales normal y tener homogeneidad de las varianzas.

Se cuenta con la independencia de los observaciones, dado la forma en que se realizo el experimento, es decir ningún experimento dependía de la ejecución u orden del anterior, ya que no hay memoria de los resultados ni tampoco entre núcleos, ya que cada uno genera una cola diferente.

Para comprobar que la distribución de residuales viene de una distribución normal se realizo una prueba de Shapiro-Wilki para cada Núcleo, teniendo los resultados en la tabla \ref{table:1}

\begin{table}[h!]
\centering
\begin{tabular}{c c}  
 Núcleos & Valor $p$ Prueba Shapiro-Wilk \\ [0.5ex] 
 \hline \hline
 2 & 6.504e-14 \\
 3 & 6.736e-13 \\
 4 & 1.968e-11 \\
 5 & 3.277e-09 \\
 6 & 2.523e-06 \\
 7 & 4.778e-08 \\
 \hline
\end{tabular}
\caption{Tabla de valores $p$ de la prueba Shapiro-Wilk para cada núcleo con las 3 serie de ordenamientos}
\label{table:1}
\end{table}
  
Como se puede apreciar para un valor de $\alpha = 0.0005$, debemos desechar la hipótesis nula de que los datos vienen de una distribución normal. Por lo tanto se procedió a la prueba paramétrica de Kruskal-Wallis para comprobar que no había varianzas entre los ordenamientos en cada nivel, los resultados se pueden ver en la siguiente tabla \ref{table:2}

\begin{table}[h!]
\centering
\begin{tabular}{c c c c}  
 Núcleos & Valor $\chi^2$ & Grados de libertad & Valor $p$  \\ [0.5ex] 
 \hline\hline
 2 & 62.663 & 2 & 2.471e-14 \\
 3 & 13.079 & 2 & 0.001445 \\
 4 & 1.0875 & 2 & 0.5806 \\
 5 & 3.4505 & 2 & 0.1781 \\
 6 & 3.7433 & 2 & 0.1539 \\
 7 & 1.959  & 2 & 0.3755 \\
 \hline
\end{tabular}
\caption{Tabla de valores de la prueba Kruskal-Wallis para cada núcleo con las 3 serie de ordenamientos}
\label{table:2}
\end{table}

Con los resultados de la prueba, podemos ver que solo para dos núcleos, hay diferencias en las varianzas y de tres núcleos en adelante, se puede aceptar con un valor de $\alpha = 0.0005$, que las varianzas son iguales para cada ordenamiento, que era lo que se observó en los resultados de la tarea.


\section{Conclusiones}

En esta práctica se trabajo el efecto del paralelismo de tareas desde la teoría de colas, en como su uso reduce el tiempo de procesamiento de las taras. Por otra parte se pudo observar que hay estructuras en las tareas que pueden afectar el tiempo de ejecución de la Tarea en función de su estructura y el número de núcleos del procesador asignados para la tarea y se puedo conocer la manera en como funciona la librería parallel para poder utilizarla de manera que se pueda aprovechar su paralelizacion.

\end{document}
