%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  para un artículo en LaTeX en español.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[]{article}
% Esto es para poder escribir acentos directamente:
\usepackage[latin1]{inputenc}
% Esto es para que el LaTeX sepa que el texto estÃ¡ en espaÃ±ol:
\usepackage[spanish]{babel}
\decimalpoint
%para cambiar los margenes del texto
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
% Paquetes de la AMS:
%\usepackage{amsmath, amsthm, amsfonts,float}
\graphicspath{ {../Tarea_6/images/} }


%--------------------------------------------------------------------------
\title{Reporte práctica seis: Sistemas multiagente}
\author{José Anastacio Hernández Saldaña\\
  \small Posgrado de Ingeniería de Sistemas\\
  \small 1186622\\ 
  \small jose.hernandezsld@uanl.edu.mx
}

\begin{document}

\maketitle

\abstract{Este es un reporte sobre la práctica seis con respecto al
  tema de sistemas multiagente que se realizó en la clase de
  Simulación de sistemas, cómputo paralelo en R.}


\section{Tarea: Implementación paralela de un sistea multiagente}

Un sistema multiagente es un sistema computacional donde interactúan
varios agentes dentro de un ambiente o entorno, los agentes realizan
acciones en el ambiente y a partir del estado del ambiente el agente
realiza alguna acción. Este tipo de sistemas son descentralizados, es
decir, los agentes no siguen órdenes de una unidad central, sino que
cada agente es autónomo.

Para esta tarea se realizó una simulación de una epidemia de una
cantidad $n$ de agentes, donde cada agente podría estar en alguno de
los siguientes estados: sano, infectado e inmune. El agente estaba
sano si no se había contagiado al estar cerca de algún otro agente
infectado, si estaba a una distancia $d$ del infectado tal que era
menor a un umbral $r$, hay una probabilidad $p_i = \frac{r-d}{r}$ de
infectarse en otro caso $p_r= 0$, si el agente estaba infectado, tenia
una probabilidad $p_r$ de recuperarse y volverse inmune. Cada agente
tenia una velocidad horizontal y vertical $dx$ y $dy$ respectivamente,
asi que en cada paso de la simulacion los agentes avanzaban en funcion
de su posicion inicial y su velocidad y se volvian a hacer los
calculos para definir su estado, todo esto dentro de un espacio de
dimensiones $l \times l$, el cual esta en forma de un torus o dona, ya
que al exceder alguno de los bordes, el agente aparece en borde
contrario.

\subsection{Diseño del Experimento}

Para el experimento se tomó como base el código de la
\href{http://elisa.dyndns-web.com/teaching/comp/par/p6.html}{página
  del curso}, donde se encuentra la simulación ya programada con los
siguientes parámetros, umbral de infección $r= 0.1$, probabilidad de
recuperación $p_r=0.2$, con una dimensión de $l=1.5$, se tienen una
cantidad de agentes de $n=50$, estos se creaban posiciones $x$, $y$
con velocidades $dx$, $dy$ tomadas de una distribucion uniforme tal
que $0 \leq x \leq l$ y $\frac{-l}{30} \leq dx \leq \frac{l}{30}$, de
manera similar para $y$ y $dy$. El estado inicial de los agentes era
asignado con una probabilidad $\alpha_i =0.05$ de comenzar infectado y
una probabilidad $1-\alpha_i$ de comenzar sano.

Este código no se encuentra paralelizado y cuenta con varias opciones
para paralelizarse y optimizarse identificadas, que son las
siguientes:
\begin{enumerate}
\item Asignación de estado inicial. \label{AEI} La asignación se hace
  de manera iterativa para cada uno de los agentes puede hacerse de
  manera paralela.
  \item Cálculo de la distancia de un agente y los agentes
    cercanos. \label{CDA} El cálculo de distancia en cada agente hacia
    todos los demas puede hacerse de manera paralela y puede mejorarse
    si se reduce la cantidad de agentes a comparar.
  \item Asignación de posiciones y velocidades iniciales. \label{APV}
    Esta asignación también se hace de manera iterativa para cada
    agente, dando la opción de paralelizarse.
\end{enumerate}

Como el cálculo \ref{CDA} se hace dentro del código de la asignación
\ref{AEI}, estas pueden tener problemas si ambas se paralelizan ya que
paralelizar procedimientos paralelos los hace competir por los
recursos del procesador, asi que se decidió paralelizar la asignación
de estados, y optimizar el cálculo de la distancia. Otro enfoque
tambien considerado fue utilizar un método de linea de barrido para
las asignaciones \ref{AEI}, \ref{APV} y que optimiza el cálculo
\ref{CDA} ya que en cada iteracion de la linea de barrido considera
solo aquellos agentes que se encuentran a una distancia $r$ de la
linea, evitando calcular la distancia de agentes mas allá del
umbral. Aunque el algoritmo de linea de barrido puede paralelizarse en
el cálculo de la distancia \ref{CDA} no daria mucha mejora ya que la
cantidad de agentes es pequeña y la paralilzacion de las asignaciones
denpende de la iteracion anterior por lo que no podria paralelizarse.
Pero tomando en cuenta el enfoque de linea de barrido puede hacerse
una version paralela de este codigo sí en lugar de llevar un regitro
de quienes estan dentro de la linea de barrido e ir actualizandolo
cada iteracion, puede para cada punto de la linea de barrido
calcularse los vecinos cercanos.

Por lo que se tuvieron cuatro algoritmos para comparar, que se clasificaron de la siguiente manera
\begin{enumerate}
\item Algoritmo orginal
\item Algoritmo original paralelizado
\item Algoritmo de linea de barrido
\item Algoritmo basado en linea de barrido paralelizado 
\end{enumerate}

Se decidio comprar los cuatro algoritmos para poder comparar si utlizar un buen algoritmo, como lo es el de linea de barrido, contra una implementacion paralela del algorimo original, y una implementacion paralela basada en la linea de barrido, el algoritmo original se tomo como cora superior de lo que podriamos esperar del desempeño de los algorimos, el código de los cuatro algoritmo esta dentro del \href{https://github.com/ppGodel/Parallel_R/tree/master/Tarea_6}{repositorio git} del curso.


Para comenzar la experimentación, se utilizó una computadora con las
siguientes especificaciones, Procesador Intel Core i7-4790 CPU @
3.6GHz $\times$ 8 y Memoria RAM de 24 GB. Utilizando solamente los
cuatro núcleos físicos disponibles. Para cada experimento se hicieron
30 replicas.



esta gráfica en la
figura \ref{fig::figura1}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{fx}
  \caption{Gráfica de la función $f(x)=\frac{1}{e^{x}+e^{-x}}$}
  \label{fig::figura1} 
\end{figure}


\subsection{Resultados}


\section{Extra Uno: Aproximación del valor de $\pi$}


\subsection{Diseño del Experimento}


\subsection{Resultados}

\section{Extra Dos: Pruebas estadísticas a las series sucesivas}

\section{Conclusiones}

\end{document}
